module Main3 exposing (..)

import Init
import Node exposing (Environment)
import Task exposing (Task)
import Stream
import Bytes exposing (Bytes)
import Process
import Dict exposing (Dict)
import HttpServer exposing (Request, Server)
import HttpServer.Response as Response exposing (Response)
import Url.Parser as P exposing ((</>), (<?>))
import Url exposing (Url)
import Url.Parser.Query as Query

{-

echo ./src/Main3.gren | entr -rc bash -c 'gren make ./src/Main3.gren && PORT=3000 node app'

 -}


red : String
red =
    "\u{001B}[31m"

yellow : String
yellow =
    "\u{001B}[33m"

blue : String
blue =
    "\u{001B}[34m"



reset : String
reset =
    "\u{001B}[0m"


puts : String -> Stream.Writable Bytes -> Task Never {}
puts str stdout =
    Stream.writeLineAsBytes str stdout
    |> Task.map (\_ -> {})
    |> Task.onError (\_ -> Task.succeed {})


type Route
    = Home
    | Blogs
    | Blog { id : Int, subSectionId : Maybe Int, other : Bool }

routeParser : P.Parser (Route -> a) a
routeParser =
    P.oneOf
        [ P.map Home  (P.top)
        , P.map Blogs (P.s "blog")
        , P.map
            (\id subSectionId other ->
                Blog
                    { id = id
                    , subSectionId = Maybe.andThen String.toInt subSectionId
                    , other = when other is
                        Just "1" -> True
                        _ -> False
                    }
            )
            (P.s "blog" </> P.int <?> Query.string "q" <?> Query.string "r")
        ]


urlToRoute : Url -> Maybe Route
urlToRoute url =
    let
        dropQuestion query
            = Just <|
                if String.startsWith "?" query then
                    String.dropFirst 1 query
                else
                    query
    in
    P.parse
        routeParser
        (when url.query is
            Nothing ->
                url
            Just query ->
                { url | query = dropQuestion query }
        )

type Model
    = StartingUp { port_ : Int, stdout : Stream.Writable Bytes }
    | StartingUpFailed
    | Running Server

type alias RunningModel
    = {}


type Msg
    = ServerCreated (Result HttpServer.ServerError Server)
    | GotRequest { req : Request, res : Response }
    | NOOP

main : Node.Program Model Msg
main =
    Node.defineProgram
        { init = init
        , update = update
        , subscriptions = subscriptions
        }


subscriptions : Model -> Sub Msg
subscriptions model =
    when model is
        StartingUp _ ->
            Sub.none
        StartingUpFailed ->
            Sub.none
        Running server ->
            HttpServer.onRequest server
                (\req res -> GotRequest {req = req, res = res})

init : Environment -> Init.Task { model : Model, command : Cmd Msg }
init env =
    Init.awaitTask Node.getEnvironmentVariables <| \vars ->
    Init.await HttpServer.initialize <| \serverPermissions ->
        let
            port_ =
                Dict.get "PORT" vars
                |> Maybe.andThen String.toInt
                |> Maybe.withDefault 8080
        in
        Node.startProgram
            { model = StartingUp { port_ = port_, stdout = env.stdout }
            , command =
                Task.attempt ServerCreated <|
                    HttpServer.createServer serverPermissions
                        { host = "localhost"
                        , port_ = port_
                        }
            }

printServerSuccess : Stream.Writable Bytes -> Cmd Msg
printServerSuccess stdout =
    Task.succeed stdout
    |> Task.andThen (\_ -> puts "Server created successfully" stdout)
    |> Task.andThen (\_ -> puts "wat" stdout)
    |> Task.execute

printServerSuccess2 : Stream.Writable Bytes -> Cmd Msg
printServerSuccess2 stdout =
    [ puts "Server created successfully"
    , puts "Now I will server requests"
    ]
    |> Array.map (\f -> f stdout)
    |> Task.sequence
    |> Task.execute


homeResponse : Response -> Response
homeResponse =
    Response.setBody "You requested: Home"


blogsResponse : Response -> Response
blogsResponse =
    Response.setBody "You requested: Blogs"


-- http -v localhost:4000/blog/1 q==42 r==1
blogResponse : { id : Int, subSectionId : Maybe Int, other : Bool } -> Response -> Response
blogResponse {id, subSectionId, other } =
    let _ = Debug.log "blogResponse" {id = id, subSectionId = subSectionId, other = other } in
    Response.setBody <|
        "You requested: Blog id "
        ++ String.fromInt id
        ++ " (params="
        ++ (Debug.toString {id = id, subSectionId = subSectionId, other = other })
        ++ ")"


serveRequest : Request -> Response -> Cmd Msg
serveRequest req res =
    when urlToRoute req.url is
        Nothing ->
            res
            |> Response.setStatus 404
            |> Response.send
        Just route ->
            Response.send <|
                when route is
                    Home    -> homeResponse res
                    Blogs   -> blogsResponse res
                    Blog params -> blogResponse params res


update : Msg -> Model -> { model : Model, command : Cmd Msg }
update msg model =
    let
        noop = { model = model, command = Cmd.none }
    in
    when msg is
        ServerCreated result ->
            when model is
                StartingUp { port_ = port_, stdout } ->
                    when result is
                        Ok server ->
                            { model = Running server
                            , command =
                                [ puts <| "Server booting up!"
                                , puts <| "Listening on port "
                                       ++ blue
                                       ++ (String.fromInt port_)
                                       ++ reset
                                       ++ "!"
                                ]
                                |> Array.map (\f -> f stdout)
                                |> Task.sequence
                                |> Task.execute

                            }
                        Err error ->
                            -- let _ = Debug.log "Server error" error in
                            { model = StartingUpFailed
                            , command =
                                Task.succeed {}
                                |> Task.andThen (\{} -> puts (red ++ "Server failed to start" ++ reset) stdout)
                                |> Task.andThen (\{} -> Node.exitWithCode 1)
                                |> Task.execute
                            }

                _ -> noop
        GotRequest {req, res} ->
            -- let _ = Debug.log "Request URL" req.url in
            { model = model
            , command = serveRequest req res

            }
        NOOP ->
            noop
