port module Main3 exposing (..)

import Init
import Node exposing (Environment)
import Task exposing (Task)
import Stream
import Bytes exposing (Bytes)
import Process
import Dict exposing (Dict)
import HttpServer exposing (Request, Server)
import HttpServer.Response as Response exposing (Response)
import Url.Parser as P exposing ((</>), (<?>))
import Url exposing (Url)
import Url.Parser.Query as Query


port toJS : String -> Cmd msg
port fromJS : (String -> msg) -> Sub msg


{-

echo ./src/Main3.gren | entr -rc bash -c 'gren make ./src/Main3.gren && PORT=3000 node app'
rg --type-add 'gren:*.gren' -t gren --files | entr -rc bash -c 'gren make ./src/Main3.gren --output=main.js && PORT=4000 node ./start.js'

 -}


red : String
red =
    "\u{001B}[31m"

yellow : String
yellow =
    "\u{001B}[33m"

blue : String
blue =
    "\u{001B}[34m"



reset : String
reset =
    "\u{001B}[0m"


puts : String -> Stream.Writable Bytes -> Task Never {}
puts str stdout =
    Stream.writeLineAsBytes str stdout
    |> Task.map (\_ -> {})
    |> Task.onError (\_ -> Task.succeed {})


type Route
    = Home
    | Blogs
    | Blog { id : Int, subSectionId : Maybe Int, other : Bool }

routeParser : P.Parser (Route -> a) a
routeParser =
    P.oneOf
        [ P.map Home  (P.top)
        , P.map Blogs (P.s "blog")
        , P.map
            (\id subSectionId other ->
                Blog
                    { id = id
                    , subSectionId = Maybe.andThen String.toInt subSectionId
                    , other = when other is
                        Just "1" -> True
                        _ -> False
                    }
            )
            (P.s "blog" </> P.int <?> Query.string "q" <?> Query.string "r")
        ]


urlToRoute : Url -> Maybe Route
urlToRoute url =
    let
        dropQuestion query
            = Just <|
                if String.startsWith "?" query then
                    String.dropFirst 1 query
                else
                    query
    in
    P.parse
        routeParser
        (when url.query is
            Nothing ->
                url
            Just query ->
                { url | query = dropQuestion query }
        )


type Status
    = StartingUp { port_ : Int }
    | StartingUpFailed
    | Running Server


type alias Model =
    { status : Status
    , stdout : Stream.Writable Bytes
    }


type Msg
    = ServerCreated (Result HttpServer.ServerError Server)
    | GotRequest { req : Request, res : Response }
    | NOOP
    | Rcv String

main : Node.Program Model Msg
main =
    Node.defineProgram
        { init = init
        , update = update
        , subscriptions = subscriptions
        }


subscriptions : Model -> Sub Msg
subscriptions model =
    Sub.batch
        [ fromJS Rcv
        , when model.status is
            StartingUp _ ->
                Sub.none
            StartingUpFailed ->
                Sub.none
            Running server ->
                HttpServer.onRequest server
                    (\req res -> GotRequest {req = req, res = res})
        ]

init : Environment -> Init.Task { model : Model, command : Cmd Msg }
init env =
    Init.awaitTask Node.getEnvironmentVariables <| \vars ->
    Init.await HttpServer.initialize <| \serverPermissions ->
        let
            port_ =
                Dict.get "PORT" vars
                |> Maybe.andThen String.toInt
                |> Maybe.withDefault 8080
        in
        Node.startProgram
            { model =
                { status = StartingUp { port_ = port_ }
                , stdout = env.stdout
                }
            , command =
                Task.attempt ServerCreated <|
                    HttpServer.createServer serverPermissions
                        { host = "localhost"
                        , port_ = port_
                        }
            }

printServerSuccess : Stream.Writable Bytes -> Cmd Msg
printServerSuccess stdout =
    Task.succeed stdout
    |> Task.andThen (\_ -> puts "Server created successfully" stdout)
    |> Task.andThen (\_ -> puts "wat" stdout)
    |> Task.execute

printServerSuccess2 : Stream.Writable Bytes -> Cmd Msg
printServerSuccess2 stdout =
    [ puts "Server created successfully"
    , puts "Now I will server requests"
    ]
    |> Array.map (\f -> f stdout)
    |> Task.sequence
    |> Task.execute


homeResponse : Response -> Response
homeResponse =
    Response.setBody "You requested: Home"


blogsResponse : Response -> Response
blogsResponse =
    Response.setBody "You requested: Blogs"


-- http -v localhost:4000/blog/1 q==42 r==1
blogResponse : { id : Int, subSectionId : Maybe Int, other : Bool } -> Response -> Response
blogResponse {id, subSectionId, other } =
    let _ = Debug.log "blogResponse" {id = id, subSectionId = subSectionId, other = other } in
    Response.setBody <|
        "You requested: Blog id "
        ++ String.fromInt id
        ++ " (params="
        ++ (Debug.toString {id = id, subSectionId = subSectionId, other = other })
        ++ ")"


serveRequest : Request -> Response -> Cmd Msg
serveRequest req res =
    when urlToRoute req.url is
        Nothing ->
            res
            |> Response.setStatus 404
            |> Response.send
        Just route ->
            Cmd.batch
                [ Response.send <|
                    when route is
                        Home    -> homeResponse res
                        Blogs   -> blogsResponse res
                        Blog params -> blogResponse params res
                , toJS "Serving a request"
                ]



update : Msg -> Model -> { model : Model, command : Cmd Msg }
update msg model =
    let
        noop = { model = model, command = Cmd.none }
    in
    when msg is
        ServerCreated result ->
            when model.status is
                StartingUp { port_ = port_ } ->
                    when result is
                        Ok server ->
                            { model = { model | status = Running server }
                            , command =
                                [ puts <| "Server booting up!"
                                , puts <| "Listening on port "
                                       ++ blue
                                       ++ (String.fromInt port_)
                                       ++ reset
                                       ++ "!"
                                ]
                                |> Array.map (\f -> f model.stdout)
                                |> Task.sequence
                                |> Task.execute

                            }
                        Err error ->
                            -- let _ = Debug.log "Server error" error in
                            { model = { model | status = StartingUpFailed }
                            , command =
                                Task.succeed {}
                                |> Task.andThen (\{} -> puts (red ++ "Server failed to start" ++ reset) model.stdout)
                                |> Task.andThen (\{} -> Node.exitWithCode 1)
                                |> Task.execute
                            }

                _ -> noop
        GotRequest {req, res} ->
            -- let _ = Debug.log "Request URL" req.url in
            { model = model
            , command = serveRequest req res
            }

        Rcv str ->
            -- let _ = Debug.log "Rcv" str in
            { model = model
            , command =
                puts ("Rcv :: " ++ yellow ++ str ++ reset) model.stdout
                |> Task.execute
            }
        NOOP ->
            noop
